<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Bots" xml:space="preserve">
    <value>Bots</value>
  </data>
  <data name="by" xml:space="preserve">
    <value>von</value>
  </data>
  <data name="ConcurrentProxyMode" xml:space="preserve">
    <value>Concurrent Proxy Modus</value>
  </data>
  <data name="Config" xml:space="preserve">
    <value>Config</value>
  </data>
  <data name="DataPool" xml:space="preserve">
    <value>Datenbestand</value>
  </data>
  <data name="Default" xml:space="preserve">
    <value>Standard</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>Was sind diese Optionen?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>Wenn du einen MultiRun Job erstellst, musst du eine %Config% angeben. Im Abschnitt %ConfigS% kannst du deine eigene erstellen oder eine bestehende importieren. Sobald du eine Config im Debugger des Configs-Bereichs getestet hast, kannst du sie hier auswählen, um sie mit mehreren parallel laufenden Bots auszuführen. Klicke einfach auf den %Config auswählen% Button und du kannst deine Config aus einer Liste auswählen. Es wird dir auch eine Vorschau der %LiesMich% Datei der Config angezeigt.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>Der %Proxy-Modus% entscheidet, ob Proxies verwendet werden, wenn die ausgewählte Konfiguration ausgeführt wird. Wenn du ihn auf %Default% belässt, wird er das verwenden, was in den Einstellungen der Konfiguration angegeben ist (Abschnitt Proxies, Option %Proxies benutzen%). Wenn du %Ja% oder %Nein% auswählst, wird die Standardeinstellung außer Kraft gesetzt.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>%Bots% sind die Anzahl der parallelen Worker, die deine Konfiguration ausführen werden, jeder mit seiner eigenen Datenzeile aus dem Datenbestand, den du angegeben hast (zum Beispiel eine Wordlist). Je mehr Bots du einstellst, desto mehr Anfragen werden gleichzeitig gestellt, aber beachte, dass es ein %Limit% gibt, das von der Hardware deiner Maschine abhängt, nach dem die Erhöhung der Anzahl der Bots die Leistung verschlechtert!</value>
  </data>
  <data name="Help1x04" xml:space="preserve">
    <value>Die %überspringen% Einstellung legt fest, wie viele Zeilen ab dem Beginn ​des Datenpools übersprungen werden sollen. Dieser Wert wird automatisch gesetzt, sobald du ein Paar aus Config und Wordlist auswählst, das du schon einmal ausgeführt hast, da Checkpoints deines Fortschritts periodisch in der Datenbank gespeichert werden.</value>
  </data>
  <data name="Help2x00" xml:space="preserve">
    <value>Was ist ein Datenbestand?</value>
  </data>
  <data name="Help2x01" xml:space="preserve">
    <value>Ein %Datenbestand% ist die Quelle für alle Datenzeilen, die den Bots zugewiesen werden. Der Datenbestand wird Zeile für Zeile ausgelesen und sobald ein Bot verfügbar ist, wird ihm eine Zeile zugewiesen, die er bearbeiten kann. Es gibt verschiedene Wege, einen Datenbestand zu initialisieren. Der gebräuchlichste Weg ist über eine %Wordlist%. Um eine Wordlist zu verwenden, musst du zuerst eine im Bereich %Wordlists% importieren. Sobald du eine Wortlist importiert hast, klicke einfach auf den %Wortlist% Button und wähle die Wordlist aus, die du verwenden möchtest. Du wirst auch eine Vorschau der ersten paar Zeilen der Wordlist sehen können.</value>
  </data>
  <data name="Help2x02" xml:space="preserve">
    <value>Wenn du die %Datei% Option wählst, kannst du die Importphase der Wortliste umgehen, aber bedenke, dass dies einige Funktionen deaktiviert, wie z.B. das Speichern des Fortschritts deines Wortlisten-Konfigurationspaares in der Datenbank und die Beziehung zwischen den Treffern und der Wortliste, die verwendet wurde, um sie zu erhalten. Wordlists sind der bevorzugte Weg, um Daten aus einer Datei zu verwenden, also empfehle ich dir, die Wordlists Sektion zu lesen! Du musst auch den %Wordlist Art% angeben, siehe den Abschnitt Wordlists für mehr Hilfe, was diese Option bedeutet.</value>
  </data>
  <data name="Help2x03" xml:space="preserve">
    <value>Die %Bereich% Option generiert einfach einen Zahlenbereich, ausgehend von einem Anfangswert. Wenn du zum Beispiel %Start% = 0, %Anzahl% = 5 und %Schrittweite% = 2 einstellst, werden 5 Datenzeilen mit den Werten 0, 2, 4, 6 und 8 erzeugt. Wenn du die %Pad% Box anklickst, wird die Zahl entsprechend der Anzahl der Ziffern der größten Zahl, die generiert wird, nach links mit Nullen aufgefüllt, z.B. wenn die größte Zahl 100 ist, wirst du Werte wie 001, 042 etc. in deinem generierten Datenbestand sehen.</value>
  </data>
  <data name="Help2x04" xml:space="preserve">
    <value>Die Option %Kombinationen% erlaubt es dir, alle möglichen Kombinationen eines gegebenen %Zeichensatzes% für eine gegebene %Länge% zu generieren. Wenn du zum Beispiel ABCD als Zeichensatz und Länge = 4 verwendest, erhältst du Kombinationen wie AAAA, AAAB, ... ACCB ... DDDC, DDDD.</value>
  </data>
  <data name="Help2x05" xml:space="preserve">
    <value>Die Option %Unendlich% erzeugt einfach eine unendliche Anzahl von leeren Datenzeilen, so dass der Job weiterläuft, bis du dich entscheidest, ihn zu beenden.</value>
  </data>
  <data name="Help3x00" xml:space="preserve">
    <value>Was ist eine Proxy-Quelle?</value>
  </data>
  <data name="Help3x01" xml:space="preserve">
    <value>%Proxy-Quellen% werden verwendet, um zu definieren, woher die Proxys genommen werden, wenn sie dem Pool von Proxys hinzugefügt werden, die den Bots zugewiesen werden. Proxy-Quellen werden beim Start eines Jobs abgefragt und auch immer dann, wenn alle Proxys gebannt sind oder eine Bedingung das Nachladen von Proxys erzwingt. Eine Proxyquelle vom Typ %Gruppe% nimmt Proxys aus einer Gruppe, die im Abschnitt %Proxies% definiert ist. Um diese Option zu nutzen, musst du eine Gruppe mit einigen Proxies darin haben, siehe Abschnitt Proxies für eine Anleitung, wie man das macht.</value>
  </data>
  <data name="Help3x02" xml:space="preserve">
    <value>Eine Proxyquelle vom Typ %Datei% lädt Proxys aus einer bestimmten Datei auf der Festplatte. Du kannst den vollständigen Pfad zu der gewünschten Datei eingeben und auch die Proxy %Art%, die als Standard verwendet wird, wenn keine durch die erweiterte Syntax angegeben wurde. Du kannst den Inhalt der Datei jederzeit bearbeiten und beim nächsten Proxy-Reload werden deine neuen Proxys aus der Datei geparst.</value>
  </data>
  <data name="Help3x03" xml:space="preserve">
    <value>Eine Proxy-Quelle vom Typ %Remote% beinhaltet die Abfrage einer entfernten Ressource, z.B. eines API-Dienstes eines Proxy-Anbieters, um Proxies zu erhalten. Auch hier musst du eine Proxy %Art% angeben, der als Standardoption verwendet werden soll. Diese Option kann verwendet werden, um frische, funktionierende Proxys abzurufen, die bereits von einem externen Dienst geprüft wurden.</value>
  </data>
  <data name="Help4x00" xml:space="preserve">
    <value>Was ist eine Treffer Ausgabe?</value>
  </data>
  <data name="Help4x01" xml:space="preserve">
    <value>Ein %Treffer Ausgabe% ist ein Ort, an den die Treffer gesendet werden, nachdem sie gefunden wurden. Die %Datenbank% Option (es kann nur eine geben) wird die Treffer in die Standarddatenbank von OpenBullet 2 schreiben. Du kannst die Treffer in der Datenbank über den %Treffer% Bereich einsehen. Die Option %Dateisystem% (es kann nur eine geben) wird die Treffer in einer organisierten Ordnerstruktur auf der Festplatte speichern. Schreibe einfach den Pfad zu dem Basisverzeichnis, in dem die Ordnerstruktur erstellt werden soll.</value>
  </data>
  <data name="Help4x02" xml:space="preserve">
    <value>Schließlich kannst du mit der Option %Discord webhook% die Treffer an einen Discord-Webhook senden, indem du einen benutzerdefinierten Benutzernamen und einen Avatar angibst (über die URL eines Bildes, das in einem öffentlichen Repository gehostet wird). Um diese Option zu nutzen, musst du einen Discord-Webhook für einen Channel auf deinem Server erstellen und die URL in das entsprechende Feld einfügen.</value>
  </data>
  <data name="HitOutputs" xml:space="preserve">
    <value>Treffer Ausgaben</value>
  </data>
  <data name="MarkAsToCheckOnAbort" xml:space="preserve">
    <value>Markiere als Zur Überprüfung bei Abbruch</value>
  </data>
  <data name="NeverBanProxies" xml:space="preserve">
    <value>Proxys niemals bannen</value>
  </data>
  <data name="NoConfigSelected" xml:space="preserve">
    <value>Keine Config ausgewählt</value>
  </data>
  <data name="NoValidProxyBehaviour" xml:space="preserve">
    <value>Kein gültiger Proxy Verhalten</value>
  </data>
  <data name="Off" xml:space="preserve">
    <value>Aus</value>
  </data>
  <data name="On" xml:space="preserve">
    <value>An</value>
  </data>
  <data name="PeriodicReloadIntervalSeconds" xml:space="preserve">
    <value>Regelmäßig Neuladen (Sekunden, 0 zum Deaktivieren)</value>
  </data>
  <data name="ProxyBanTimeSeconds" xml:space="preserve">
    <value>Proxy-Bannzeit (Sekunden)</value>
  </data>
  <data name="ProxyMode" xml:space="preserve">
    <value>Proxy-Modus</value>
  </data>
  <data name="ProxySources" xml:space="preserve">
    <value>Proxy-Quellen</value>
  </data>
  <data name="ReloadProxiesWhenAllBanned" xml:space="preserve">
    <value>Proxys neu laden wenn alle gebannt sind</value>
  </data>
  <data name="SelectConfig" xml:space="preserve">
    <value>Config auswählen</value>
  </data>
  <data name="ShuffleProxies" xml:space="preserve">
    <value>Proxys durchmischen</value>
  </data>
  <data name="Skip" xml:space="preserve">
    <value>überspringen</value>
  </data>
  <data name="StartCondition" xml:space="preserve">
    <value>Startbedingung</value>
  </data>
</root>